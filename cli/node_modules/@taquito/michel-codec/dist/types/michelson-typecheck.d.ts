import { MichelsonType, MichelsonData, MichelsonCode, MichelsonContract, MichelsonContractSection, MichelsonStackType } from "./michelson-types";
import { MichelsonError } from "./utils";
export interface Context {
    contract?: MichelsonContract;
    traceCallback?: (t: InstructionTrace) => void;
}
export declare class MichelsonTypeError extends MichelsonError<MichelsonType | MichelsonType[]> {
    data?: MichelsonData;
    /**
     * @param val Value of a type node caused the error
     * @param data Value of a data node caused the error
     * @param message An error message
     */
    constructor(val: MichelsonType | MichelsonType[], data?: MichelsonData, message?: string);
}
export declare class MichelsonInstructionError extends MichelsonError<MichelsonCode> {
    stackState: MichelsonStackType;
    /**
     * @param val Value of a type node caused the error
     * @param stackState Current stack state
     * @param message An error message
     */
    constructor(val: MichelsonCode, stackState: MichelsonStackType, message?: string);
}
export declare function assertTypeAnnotationsValid(t: MichelsonType, field?: boolean): void;
export interface InstructionTrace {
    op: MichelsonCode;
    in: MichelsonType[];
    out: MichelsonStackType;
}
export declare function contractSection<T extends "parameter" | "storage" | "code">(contract: MichelsonContract, section: T): MichelsonContractSection<T>;
export declare function contractEntryPoint(src: MichelsonContract | MichelsonType, ep?: string): MichelsonType | null;
export declare function contractEntryPoints(src: MichelsonContract | MichelsonType): [string, MichelsonType][];
export declare function assertContractValid(contract: MichelsonContract, ctx?: Context): MichelsonStackType;
export declare function assertDataValid<T extends MichelsonType>(d: MichelsonData, t: T, ctx?: Context): d is MichelsonData<T>;
export declare function functionType(inst: MichelsonCode, stack: MichelsonType[], ctx?: Context): MichelsonStackType;
export declare function assertTypesEqual<T1 extends MichelsonType | MichelsonType[], T2 extends T1>(a: T1, b: T2, field?: boolean): void;
export declare function isTypeAnnotationsValid(t: MichelsonType, field?: boolean): boolean;
export declare function isContractValid(contract: MichelsonContract, ctx?: Context): MichelsonStackType | null;
export declare function isDataValid<T extends MichelsonType>(d: MichelsonData, t: T, ctx?: Context): d is MichelsonData<T>;
export declare function isTypeEqual<T1 extends MichelsonType | MichelsonType[], T2 extends T1>(a: T1, b: T2, field?: boolean): boolean;
