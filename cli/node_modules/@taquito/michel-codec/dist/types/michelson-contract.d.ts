import { MichelsonContract, MichelsonContractSection, MichelsonType, MichelsonData, MichelsonCode, MichelsonStackType } from "./michelson-types";
import { InstructionTrace } from "./michelson-typecheck";
export interface ContractOptions {
    traceCallback?: (t: InstructionTrace) => void;
}
export declare class Contract {
    readonly contract: MichelsonContract;
    private ctx;
    readonly output: MichelsonStackType;
    constructor(contract: MichelsonContract, opt?: ContractOptions);
    static parse(src: string | object, opt?: ContractOptions): Contract;
    static parseTypeExpression(src: string | object): MichelsonType;
    static parseDataExpression(src: string | object): MichelsonData;
    section<T extends "parameter" | "storage" | "code">(section: T): MichelsonContractSection<T>;
    entryPoints(): [string, MichelsonType][];
    entryPoint(ep?: string): MichelsonType | null;
    assertDataValid<T extends MichelsonType>(d: MichelsonData, t: T): d is MichelsonData<T>;
    isDataValid<T extends MichelsonType>(d: MichelsonData, t: T): d is MichelsonData<T>;
    assertParameterValid(ep: string | null, d: MichelsonData): void;
    isParameterValid(ep: string | null, d: MichelsonData): boolean;
    functionType(inst: MichelsonCode, stack: MichelsonType[]): MichelsonStackType;
}
export declare const dummyContract: Contract;
