"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMichelsonType = exports.isMichelsonCode = exports.isMichelsonData = exports.isMichelsonScript = exports.assertMichelsonContract = exports.assertMichelsonData = exports.assertMichelsonType = exports.assertMichelsonPassableType = exports.assertMichelsonStorableType = exports.assertMichelsonPushableType = exports.assertMichelsonSerializableType = exports.assertMichelsonComparableType = exports.assertMichelsonInstruction = exports.MichelsonValidationError = exports.instructionIDs = void 0;
var utils_1 = require("./utils");
// Michelson validator
var noArgInstructionIDs = {
    "DUP": true, "SWAP": true, "SOME": true, "UNIT": true, "PAIR": true, "CAR": true, "CDR": true,
    "CONS": true, "SIZE": true, "MEM": true, "GET": true, "UPDATE": true, "EXEC": true, "APPLY": true, "FAILWITH": true, "RENAME": true, "CONCAT": true, "SLICE": true,
    "PACK": true, "ADD": true, "SUB": true, "MUL": true, "EDIV": true, "ABS": true, "ISNAT": true, "INT": true, "NEG": true, "LSL": true, "LSR": true, "OR": true,
    "AND": true, "XOR": true, "NOT": true, "COMPARE": true, "EQ": true, "NEQ": true, "LT": true, "GT": true, "LE": true, "GE": true, "SELF": true,
    "TRANSFER_TOKENS": true, "SET_DELEGATE": true, "CREATE_ACCOUNT": true, "IMPLICIT_ACCOUNT": true, "NOW": true, "AMOUNT": true,
    "BALANCE": true, "CHECK_SIGNATURE": true, "BLAKE2B": true, "SHA256": true, "SHA512": true, "HASH_KEY": true, "STEPS_TO_QUOTA": true,
    "SOURCE": true, "SENDER": true, "ADDRESS": true, "CHAIN_ID": true,
};
exports.instructionIDs = Object.assign({}, noArgInstructionIDs, {
    "DROP": true, "DIG": true, "DUG": true, "NONE": true, "LEFT": true, "RIGHT": true, "NIL": true, "UNPACK": true, "CONTRACT": true, "CAST": true,
    "IF_NONE": true, "IF_LEFT": true, "IF_CONS": true, "IF": true, "MAP": true, "ITER": true, "LOOP": true, "LOOP_LEFT": true, "DIP": true,
    "CREATE_CONTRACT": true, "PUSH": true, "EMPTY_SET": true, "EMPTY_MAP": true, "EMPTY_BIG_MAP": true, "LAMBDA": true,
});
var simpleComparableTypeIDs = {
    "int": true, "nat": true, "string": true, "bytes": true, "mutez": true,
    "bool": true, "key_hash": true, "timestamp": true, "address": true,
};
var typeIDs = {
    "address": true, "big_map": true, "bool": true, "bytes": true, "chain_id": true, "contract": true, "int": true,
    "key_hash": true, "key": true, "lambda": true, "list": true, "map": true, "mutez": true, "nat": true, "operation": true, "option": true,
    "or": true, "pair": true, "set": true, "signature": true, "string": true, "timestamp": true, "unit": true,
};
var MichelsonValidationError = /** @class */ (function (_super) {
    __extends(MichelsonValidationError, _super);
    /**
     * @param val Value of a node caused the error
     * @param message An error message
     */
    function MichelsonValidationError(val, message) {
        var _this = _super.call(this, val, message) || this;
        _this.val = val;
        Object.setPrototypeOf(_this, MichelsonValidationError.prototype);
        return _this;
    }
    return MichelsonValidationError;
}(utils_1.MichelsonError));
exports.MichelsonValidationError = MichelsonValidationError;
function isPrim(ex) {
    return "prim" in ex;
}
function assertPrim(ex) {
    if (isPrim(ex)) {
        return true;
    }
    throw new MichelsonValidationError(ex, "prim expression expected");
}
function assertSeq(ex) {
    if (Array.isArray(ex)) {
        return true;
    }
    throw new MichelsonValidationError(ex, "sequence expression expected");
}
function assertNatural(i) {
    if (i.int[0] === "-") {
        throw new MichelsonValidationError(i, "natural number expected");
    }
}
function assertIntLiteral(ex) {
    if ("int" in ex) {
        return true;
    }
    throw new MichelsonValidationError(ex, "int literal expected");
}
function assertArgs(ex, n) {
    var _a;
    if ((n === 0 && ex.args === undefined) || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {
        return true;
    }
    throw new MichelsonValidationError(ex, n + " arguments expected");
}
/**
 * Checks if the node is a valid Michelson code (sequence of instructions).
 * This is a type guard function which either returns true of throws an exception.
 * @param ex An AST node
 */
function assertMichelsonInstruction(ex) {
    var e_1, _a;
    var _b, _c;
    if (Array.isArray(ex)) {
        try {
            for (var ex_1 = __values(ex), ex_1_1 = ex_1.next(); !ex_1_1.done; ex_1_1 = ex_1.next()) {
                var n = ex_1_1.value;
                if (!Array.isArray(n) && !isPrim(n)) {
                    throw new MichelsonValidationError(ex, "sequence or prim expected");
                }
                assertMichelsonInstruction(n);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (ex_1_1 && !ex_1_1.done && (_a = ex_1.return)) _a.call(ex_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return true;
    }
    if (assertPrim(ex)) {
        if (Object.prototype.hasOwnProperty.call(noArgInstructionIDs, ex.prim)) {
            assertArgs(ex, 0);
            return true;
        }
        switch (ex.prim) {
            case "DROP":
                if (ex.args !== undefined && assertArgs(ex, 1)) {
                    /* istanbul ignore else */
                    if (assertIntLiteral(ex.args[0])) {
                        assertNatural(ex.args[0]);
                    }
                }
                break;
            case "DIG":
            case "DUG":
                /* istanbul ignore else */
                if (assertArgs(ex, 1)) {
                    /* istanbul ignore else */
                    if (assertIntLiteral(ex.args[0])) {
                        assertNatural(ex.args[0]);
                    }
                }
                break;
            case "NONE":
            case "LEFT":
            case "RIGHT":
            case "NIL":
            case "CAST":
                /* istanbul ignore else */
                if (assertArgs(ex, 1)) {
                    assertMichelsonType(ex.args[0]);
                }
                break;
            case "UNPACK":
                /* istanbul ignore else */
                if (assertArgs(ex, 1)) {
                    assertMichelsonSerializableType(ex.args[0]);
                }
                break;
            case "CONTRACT":
                /* istanbul ignore else */
                if (assertArgs(ex, 1)) {
                    assertMichelsonPassableType(ex.args[0]);
                }
                break;
            case "IF_NONE":
            case "IF_LEFT":
            case "IF_CONS":
            case "IF":
                /* istanbul ignore else */
                if (assertArgs(ex, 2)) {
                    /* istanbul ignore else */
                    if (assertSeq(ex.args[0])) {
                        assertMichelsonInstruction(ex.args[0]);
                    }
                    /* istanbul ignore else */
                    if (assertSeq(ex.args[1])) {
                        assertMichelsonInstruction(ex.args[1]);
                    }
                }
                break;
            case "MAP":
            case "ITER":
            case "LOOP":
            case "LOOP_LEFT":
                /* istanbul ignore else */
                if (assertArgs(ex, 1)) {
                    assertMichelsonInstruction(ex.args[0]);
                }
                break;
            case "CREATE_CONTRACT":
                /* istanbul ignore else */
                if (assertArgs(ex, 1)) {
                    assertMichelsonContract(ex.args[0]);
                }
                break;
            case "DIP":
                if (((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length) === 2) {
                    /* istanbul ignore else */
                    if (assertIntLiteral(ex.args[0])) {
                        assertNatural(ex.args[0]);
                    }
                    /* istanbul ignore else */
                    if (assertSeq(ex.args[1])) {
                        assertMichelsonInstruction(ex.args[1]);
                    }
                }
                else if (((_c = ex.args) === null || _c === void 0 ? void 0 : _c.length) === 1) {
                    /* istanbul ignore else */
                    if (assertSeq(ex.args[0])) {
                        assertMichelsonInstruction(ex.args[0]);
                    }
                }
                else {
                    throw new MichelsonValidationError(ex, "1 or 2 arguments expected");
                }
                break;
            case "PUSH":
                /* istanbul ignore else */
                if (assertArgs(ex, 2)) {
                    assertMichelsonPushableType(ex.args[0]);
                    assertMichelsonData(ex.args[1]);
                }
                break;
            case "EMPTY_SET":
                /* istanbul ignore else */
                if (assertArgs(ex, 1)) {
                    assertMichelsonComparableType(ex.args[0]);
                }
                break;
            case "EMPTY_MAP":
                /* istanbul ignore else */
                if (assertArgs(ex, 2)) {
                    assertMichelsonComparableType(ex.args[0]);
                    assertMichelsonType(ex.args[1]);
                }
                break;
            case "EMPTY_BIG_MAP":
                /* istanbul ignore else */
                if (assertArgs(ex, 2)) {
                    assertMichelsonComparableType(ex.args[0]);
                    assertMichelsonSerializableType(ex.args[1]);
                }
                break;
            case "LAMBDA":
                /* istanbul ignore else */
                if (assertArgs(ex, 3)) {
                    assertMichelsonType(ex.args[0]);
                    assertMichelsonType(ex.args[1]);
                    /* istanbul ignore else */
                    if (assertSeq(ex.args[2])) {
                        assertMichelsonInstruction(ex.args[2]);
                    }
                }
                break;
            default:
                throw new MichelsonValidationError(ex, "instruction expected");
        }
    }
    return true;
}
exports.assertMichelsonInstruction = assertMichelsonInstruction;
function assertMichelsonComparableType(ex) {
    /* istanbul ignore else */
    if (assertPrim(ex)) {
        if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeIDs, ex.prim) && ex.prim !== "pair") {
            throw new MichelsonValidationError(ex, ex.prim + ": type is not comparable");
        }
        traverseType(ex, function (ex) {
            if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeIDs, ex.prim)) {
                throw new MichelsonValidationError(ex, ex.prim + ": type is not comparable");
            }
            assertArgs(ex, 0);
        }, function (ex) { return assertMichelsonComparableType(ex); });
    }
    return true;
}
exports.assertMichelsonComparableType = assertMichelsonComparableType;
function assertMichelsonSerializableType(ex) {
    /* istanbul ignore else */
    if (assertPrim(ex)) {
        if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||
            ex.prim === "big_map" ||
            ex.prim === "operation") {
            throw new MichelsonValidationError(ex, ex.prim + ": type can't be used inside big_map or PACK/UNPACK instructions");
        }
        traverseType(ex, function (ex) { return assertMichelsonSerializableType(ex); }, function (ex) { return assertMichelsonSerializableType(ex); });
    }
    return true;
}
exports.assertMichelsonSerializableType = assertMichelsonSerializableType;
function assertMichelsonPushableType(ex) {
    /* istanbul ignore else */
    if (assertPrim(ex)) {
        if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||
            ex.prim === "big_map" ||
            ex.prim === "operation" ||
            ex.prim === "contract") {
            throw new MichelsonValidationError(ex, ex.prim + ": type can't be pushed");
        }
        traverseType(ex, function (ex) { return assertMichelsonPushableType(ex); }, function (ex) { return assertMichelsonPushableType(ex); });
    }
    return true;
}
exports.assertMichelsonPushableType = assertMichelsonPushableType;
function assertMichelsonStorableType(ex) {
    /* istanbul ignore else */
    if (assertPrim(ex)) {
        if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||
            ex.prim === "operation" ||
            ex.prim === "contract") {
            throw new MichelsonValidationError(ex, ex.prim + ": type can't be used as part of a storage");
        }
        traverseType(ex, function (ex) { return assertMichelsonStorableType(ex); }, function (ex) { return assertMichelsonStorableType(ex); });
    }
    return true;
}
exports.assertMichelsonStorableType = assertMichelsonStorableType;
function assertMichelsonPassableType(ex) {
    /* istanbul ignore else */
    if (assertPrim(ex)) {
        if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||
            ex.prim === "operation") {
            throw new MichelsonValidationError(ex, ex.prim + ": type can't be used as part of a parameter");
        }
        traverseType(ex, function (ex) { return assertMichelsonPassableType(ex); }, function (ex) { return assertMichelsonPassableType(ex); });
    }
    return true;
}
exports.assertMichelsonPassableType = assertMichelsonPassableType;
/**
 * Checks if the node is a valid Michelson type expression.
 * This is a type guard function which either returns true of throws an exception.
 * @param ex An AST node
 */
function assertMichelsonType(ex) {
    /* istanbul ignore else */
    if (assertPrim(ex)) {
        if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim)) {
            throw new MichelsonValidationError(ex, "type expected");
        }
        traverseType(ex, function (ex) { return assertMichelsonType(ex); }, function (ex) { return assertMichelsonType(ex); });
    }
    return true;
}
exports.assertMichelsonType = assertMichelsonType;
function traverseType(ex, left, child) {
    switch (ex.prim) {
        case "option":
        case "list":
            /* istanbul ignore else */
            if (assertArgs(ex, 1) && assertPrim(ex.args[0])) {
                child(ex.args[0]);
            }
            break;
        case "contract":
            /* istanbul ignore else */
            if (assertArgs(ex, 1)) {
                assertMichelsonPassableType(ex.args[0]);
            }
            break;
        case "pair":
            /* istanbul ignore else */
            if (assertArgs(ex, 2) && assertPrim(ex.args[0]) && assertPrim(ex.args[1])) {
                left(ex.args[0]);
                child(ex.args[1]);
            }
            break;
        case "or":
            /* istanbul ignore else */
            if (assertArgs(ex, 2) && assertPrim(ex.args[0]) && assertPrim(ex.args[1])) {
                child(ex.args[0]);
                child(ex.args[1]);
            }
            break;
        case "lambda":
            /* istanbul ignore else */
            if (assertArgs(ex, 2)) {
                assertMichelsonType(ex.args[0]);
                assertMichelsonType(ex.args[1]);
            }
            break;
        case "set":
            /* istanbul ignore else */
            if (assertArgs(ex, 1)) {
                assertMichelsonComparableType(ex.args[0]);
            }
            break;
        case "map":
            /* istanbul ignore else */
            if (assertArgs(ex, 2) && assertPrim(ex.args[0]) && assertPrim(ex.args[1])) {
                assertMichelsonComparableType(ex.args[0]);
                child(ex.args[1]);
            }
            break;
        case "big_map":
            /* istanbul ignore else */
            if (assertArgs(ex, 2) && assertPrim(ex.args[0]) && assertPrim(ex.args[1])) {
                assertMichelsonComparableType(ex.args[0]);
                assertMichelsonSerializableType(ex.args[1]);
                child(ex.args[1]);
            }
            break;
        default:
            assertArgs(ex, 0);
    }
    return true;
}
/**
 * Checks if the node is a valid Michelson data literal such as `(Pair {Elt "0" 0} 0)`.
 * This is a type guard function which either returns true of throws an exception.
 * @param ex An AST node
 */
function assertMichelsonData(ex) {
    var e_2, _a;
    if (("int" in ex) || ("string" in ex) || ("bytes" in ex)) {
        return true;
    }
    if (Array.isArray(ex)) {
        var mapElts = 0;
        try {
            for (var ex_2 = __values(ex), ex_2_1 = ex_2.next(); !ex_2_1.done; ex_2_1 = ex_2.next()) {
                var n = ex_2_1.value;
                if (isPrim(n) && n.prim === "Elt") {
                    /* istanbul ignore else */
                    if (assertArgs(n, 2)) {
                        assertMichelsonData(n.args[0]);
                        assertMichelsonData(n.args[1]);
                    }
                    mapElts++;
                }
                else {
                    assertMichelsonData(n);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (ex_2_1 && !ex_2_1.done && (_a = ex_2.return)) _a.call(ex_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (mapElts !== 0 && mapElts !== ex.length) {
            throw new MichelsonValidationError(ex, "data entries and map elements can't be intermixed");
        }
        return true;
    }
    if (isPrim(ex)) {
        switch (ex.prim) {
            case "Unit":
            case "True":
            case "False":
            case "None":
                assertArgs(ex, 0);
                break;
            case "Pair":
                /* istanbul ignore else */
                if (assertArgs(ex, 2)) {
                    assertMichelsonData(ex.args[0]);
                    assertMichelsonData(ex.args[1]);
                }
                break;
            case "Left":
            case "Right":
            case "Some":
                /* istanbul ignore else */
                if (assertArgs(ex, 1)) {
                    assertMichelsonData(ex.args[0]);
                }
                break;
            default:
                if (Object.prototype.hasOwnProperty.call(exports.instructionIDs, ex.prim)) {
                    assertMichelsonInstruction(ex);
                }
                else {
                    throw new MichelsonValidationError(ex, "data entry or instruction expected");
                }
        }
    }
    else {
        throw new MichelsonValidationError(ex, "data entry expected");
    }
    return true;
}
exports.assertMichelsonData = assertMichelsonData;
/**
 * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.
 * This is a type guard function which either returns true of throws an exception.
 * @param ex An AST node
 */
function assertMichelsonContract(ex) {
    var e_3, _a;
    /* istanbul ignore else */
    if (assertSeq(ex) && ex.length === 3 && assertPrim(ex[0]) && assertPrim(ex[1]) && assertPrim(ex[2])) {
        var p = [ex[0].prim, ex[1].prim, ex[2].prim].sort();
        if (p[0] === "code" && p[1] === "parameter" && p[2] === "storage") {
            try {
                for (var _b = __values(ex), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var n = _c.value;
                    /* istanbul ignore else */
                    if (assertArgs(n, 1)) {
                        switch (n.prim) {
                            case "code":
                                /* istanbul ignore else */
                                if (assertSeq(n.args[0])) {
                                    assertMichelsonInstruction(n.args[0]);
                                }
                                break;
                            case "parameter":
                                assertMichelsonPassableType(n.args[0]);
                                break;
                            case "storage":
                                assertMichelsonStorableType(n.args[0]);
                        }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        else {
            throw new MichelsonValidationError(ex, "valid Michelson script expected");
        }
    }
    return true;
}
exports.assertMichelsonContract = assertMichelsonContract;
/**
 * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.
 * @param ex An AST node
 */
function isMichelsonScript(ex) {
    try {
        assertMichelsonContract(ex);
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.isMichelsonScript = isMichelsonScript;
/**
 * Checks if the node is a valid Michelson data literal such as `(Pair {Elt "0" 0} 0)`.
 * @param ex An AST node
 */
function isMichelsonData(ex) {
    try {
        assertMichelsonData(ex);
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.isMichelsonData = isMichelsonData;
/**
 * Checks if the node is a valid Michelson code (sequence of instructions).
 * @param ex An AST node
 */
function isMichelsonCode(ex) {
    try {
        assertMichelsonInstruction(ex);
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.isMichelsonCode = isMichelsonCode;
/**
 * Checks if the node is a valid Michelson type expression.
 * @param ex An AST node
 */
function isMichelsonType(ex) {
    try {
        assertMichelsonType(ex);
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.isMichelsonType = isMichelsonType;
//# sourceMappingURL=michelson-validator.js.map